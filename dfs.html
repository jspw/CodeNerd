<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

  <!-- <script src="bootstrap.min.js"></script> -->



  <title>CodeNerd</title>
<style>
body {
  margin: 0;
  background-color: mintcream;
  
}
.centered
{
  margin: auto;
  width: 50%;
  
  
}
a{
    color: lightsalmon;
}
h1,.hint{
  text-align: center;
  letter-spacing: 2px;
}
h3{
    letter-spacing: 2px;
}
code{
  color: darkred;
  background-color: lavenderblush ;
}
.sura {
  list-style-type: none;
  margin: 0;
  padding: 0;
  width: 15%;
  background-color: #f1f1f1;
  position: fixed;
  height: 100%;
  overflow: auto;
}


li a {
  display: block;
  color: #000;
  padding: 8px 16px;
  text-decoration: none;
}

li a.active {
  background-color:#555;
  color: white;
}

li a:hover:not(.active) {
  background-color: #555;
  color: white;
}
</style>
</head>
<body id="myPage" data-spy="scroll" data-target=".navbar" data-offset="60">
  <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container-fluid">
        <div class="navbar-header">
            <!-- <button class="btn brandB"> -->
            <a class="brandB" role="button" href="home.php"><img class="img" src="codenerd.png" height="50" width="100"></a>
            <!-- </button> -->

            <button type="button" class="navbar-toggle" data-target="#navCol" data-toggle="collapse">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>

            </button>
        </div>
        <!-- Navigation bar collaspe -->

        <div class="navbar-collapse collapse" id="navCol">
            <ul class="nav navbar-nav">
                <li><a href="#HOME">HOME</a></li>
                <li><a href="#Algorithm">ALGORITHM</a></li>
                

            </ul>

            


        </div>

    </div>
</nav>
<ul class="sura">
  <li><a class="active" href="#home">Graph Traversal</a></li>
  <li><a href="./project.html">Breadth First Search</a></li>
  <li><a href="./dfs.html">Depth First Search</a></li>
  <li><a href="#about">About</a></li>
</ul>

<div style="margin-left:15%;margin-top: 3%;padding:1px 16px;height:1000px;">
    <h1>Depth First Search</h1>

  
    
    
    <div dir="ltr"><div class="centered">
        <img alt="depth first search demo" src="./img/dfs.gif"/><br/>
        <span class="hint">Depth First Search builds a long and skinny spanning tree</span>
    </div>
    
    <p><strong>Depth-First Search</strong> with its complement <a href="./project.html">Breadth-First Search</a> are two popular methods
    of searching in the graph. It is recommended to <strong>solve the exercise on BFS first</strong>.</p>
    
    <p>The <strong>Depth-First</strong> words in the title of the algorithm explain its behavior. For each discovered vertex it tries to
    choose any single neighbor node and proceed searching from it. Searching from via other neighbors is carried out only
    after the chosen branch is completely investigated.</p>
    
    <p>This algorithm also builds spanning tree (if the graph is connected), but unlike <strong>BFS</strong> it creates long branches
    (though few of them). If we are lucky as with graph represented on the picture above, the whole tree could contain
    a single branch at all!</p>
    
    <p>This makes the algorithm unsuitable for searching shortest paths. Though in some cases it is convenient when we want
    to check the existence of <strong>any</strong> path between two nodes.</p>
    
    <p>The problem of finding the loop (or loops) in a <strong>directed</strong> graph is easily solved by <strong>DFS</strong> while <strong>BFS</strong> can
    instead give us not a loop but two paths to the same vertex. Of course if the graph is undirected it will also be a
    solution.</p>
    
    <h3>Algorithm Implementation</h3>
    
    <p>Nice thing is that we need only slight modification of <strong>BFS</strong> to convert it to <strong>DFS</strong>:</p>
    
    <ol>
    <li>we should use a <code>Stack</code> instead of the <code>Queue</code> for storing vertices;</li>
    <li>we do not check whether node was <code>seen</code> when storing neighbors in the stack - instead we perform this checking when
    retrieving the node from it.</li>
    </ol>
    
    <p>You probably know that the <code>Stack</code> is similar to <code>Queue</code>, but the elements are retrieved in the reversed order, which
    is often called <code>LIFO</code>, i.e. <strong>Last in, First out</strong>. If we add elements to the end of array and retrieve it from the
    end also, then it is just the implementation of the stack.</p>
    
    <p>So here is the detailed steps of the algorithm:</p>
    
    <ol>
    <li>We add the initial node to <code>stack</code>.</li>
    <li>Remove the next element from the <code>stack</code> and call it <code>current</code>.</li>
    <li>If the <code>current</code> node was <code>seen</code> then skip it (going to step <code>6</code>).</li>
    <li>Otherwise mark the <code>current</code> node as <code>seen</code>.</li>
    <li>Get all neighbors of the <code>current</code> node and add all them to <code>stack</code>.</li>
    <li>Repeat from the step <code>2</code> until the <code>stack</code> becomes empty.</li>
    </ol>
    
    <p>You also can read <a href="http://en.wikipedia.org/wiki/Depth-first_search">wikipedia article</a> to get more clear idea.</p>
    
    <hr />
    
    <h3>Problem Statement</h3>
    
    <p>Again you should produce the array representing the spanning tree built by the algorithm. There are different ways to
    extend the algorithm to allow it remember where you came from to which nodes.</p>
    
    <p>To avoid ambiguosity please take care that neighbors should be tried in order of increasing their ids (like in <strong>BFS</strong>
    problem).</p>
    
    <p><strong>Input data</strong> will contain the amount of nodes <code>N</code> and the amount of edges <code>M</code>.<br />
    Then <code>M</code> lines will follow each containing ids of two nodes connected by an edge. Node ids are integers between <code>0</code> and <code>N-1</code>.<br />
    <strong>Answer</strong> should contain the array of values: <code>a[i]</code> should contain the index of the node from which <code>i-th</code> one was
    visited by the algorithm. It should have <code>-1</code> for the initial node, i.e. <code>a[0]=-1</code>.</p>
    
    <p>Example:</p>
    
    <pre><code>input data:
    7 10
    0 1
    2 0
    0 3
    1 4
    4 3
    2 3
    5 2
    6 3
    4 6
    6 5
    
    answer:
    -1 0 3 4 1 2 5
    </code></pre>
    
   
    
    <p>Another example:</p>
    
    <pre><code>input data
    4 4
    0 1
    1 2
    3 1
    2 0
    
    answer
    -1 0 1 1
    </code></pre>
    
    <p><em>Here we go from node <code>0</code> to <code>1</code>, then from here to <code>2</code> and this node appears to be "terminal" - it have no unvisited
    neighbors, so we track back to node <code>1</code> and from here visit the remaining <code>3</code>.</em></p>
    </div>
  
</div>

</body>
</html>